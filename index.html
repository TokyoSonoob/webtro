/**
 * Single-Room Voice Chat ‚Äî one room, auto-connect everyone
 * Run:
 *   npm i express ws
 *   node single-room-voicechat-server.js
 * Open: http://localhost:3000  (open from 2+ devices/browsers)
 *
 * Notes:
 * - Audio-only WebRTC (no Firebase). Tiny WebSocket signaling at /ws.
 * - Full mesh: good for ~2‚Äì4 people. Use SFU for larger groups.
 * - TURN optional (fill ICE_SERVERS in the client HTML below if needed).
 */

const express = require('express');
const { WebSocketServer } = require('ws');
const http = require('http');

const app = express();

// ---- Serve a single inlined HTML page ----
const CLIENT_HTML = `<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voice Chat ‚Äî ‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß (Auto connect)</title>
  <style>
    :root{--bg:#0b1220;--card:#111827;--muted:#9CA3AF;--b:#1f2937;--pri:#8b5cf6}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:#fff;font:16px/1.4 system-ui,Segoe UI,Roboto,Arial}
    .wrap{max-width:920px;margin:0 auto;padding:16px}
    h1{margin:0 0 6px;color:var(--pri)}
    .muted{color:var(--muted)}
    .card{background:var(--card);border:1px solid var(--b);border-radius:14px;padding:14px;margin-top:12px}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px}
    audio{width:100%}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{cursor:pointer;border:0;border-radius:10px;padding:8px 12px;font-weight:700}
    .ghost{background:#1f2937;color:#e5e7eb}
    .pill{font-size:12px;border:1px solid #2a385c;background:#0e1730;padding:2px 8px;border-radius:999px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üìû ‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‚Äî ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</h1>
    <div class="card">
      <div class="row">
        <div>Room:</div>
        <span class="pill">lobby</span>
        <span id="myid" class="pill"></span>
        <button id="btnMute" class="ghost">üîá ‡∏õ‡∏¥‡∏î/‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡∏Ñ‡πå</button>
      </div>
      <div id="status" class="muted" style="margin-top:8px">‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‚Ä¶</div>
    </div>
    <div class="card">
      <h3>‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏£‡πà‡∏ß‡∏°‡∏´‡πâ‡∏≠‡∏á</h3>
      <div id="peers" class="grid"></div>
      <p class="muted" style="margin-top:8px">* ‡∏ñ‡πâ‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÑ‡∏°‡πà‡∏ï‡∏¥‡∏î‡πÉ‡∏ô‡∏ö‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢ ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏° TURN ‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ ICE_SERVERS ‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á</p>
    </div>
  </div>

<script>
// ====== Config ======
const SIGNAL_URL = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws';
const ROOM = 'lobby'; // single room only
const ICE_SERVERS = [
  { urls: 'stun:stun.l.google.com:19302' },
  // { urls:'turn:YOUR_TURN_HOST:3478', username:'user', credential:'pass' },
];

// ====== Helpers ======
const MY_ID = Math.random().toString(36).slice(2,10);
const $ = (id)=>document.getElementById(id);
$('myid').textContent = 'ID: '+MY_ID;
function setStatus(t){ $('status').textContent = t; }
const log = (...a)=>console.log('[client]', ...a);

// ====== WebSocket signaling ======
let ws;
function wsSend(msg){ if (ws && ws.readyState === 1) ws.send(JSON.stringify(msg)); }

// ====== WebRTC ======
let localStream;
const pcs = new Map(); // peerId -> RTCPeerConnection

function createPeer(peerId){
  const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
  pcs.set(peerId, pc);
  pc.onicecandidate = (ev)=>{ if (ev.candidate) wsSend({ type:'ice', room:ROOM, from:MY_ID, to:peerId, payload:ev.candidate }); };
  pc.oniceconnectionstatechange = ()=>{ log(peerId,'ice:',pc.iceConnectionState); if(['failed','disconnected','closed'].includes(pc.iceConnectionState)) removePeerEl(peerId); };
  pc.ontrack = (ev)=> attachRemoteAudio(peerId, ev.streams[0]);
  return pc;
}

function attachRemoteAudio(peerId, stream){
  let wrap = document.getElementById('wrap_'+peerId);
  if (!wrap){
    wrap = document.createElement('div'); wrap.id = 'wrap_'+peerId; wrap.className = 'card';
    const title = document.createElement('div'); title.textContent = 'Peer '+peerId;
    const audio = document.createElement('audio'); audio.id = 'aud_'+peerId; audio.autoplay = true; audio.playsInline = true; audio.controls = true;
    wrap.appendChild(title); wrap.appendChild(audio);
    $('peers').appendChild(wrap);
  }
  const audio = document.getElementById('aud_'+peerId);
  audio.srcObject = stream;
}

function removePeerEl(peerId){ const wrap = document.getElementById('wrap_'+peerId); if (wrap && wrap.parentNode) wrap.parentNode.removeChild(wrap); }

async function ensureMic(){
  if (localStream) return localStream;
  try{ localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false }); }
  catch(e){ setStatus('‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÑ‡∏°‡∏Ñ‡πå‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô'); throw e; }
  return localStream;
}

async function callPeer(peerId){
  const pc = pcs.get(peerId) || createPeer(peerId);
  const stream = await ensureMic();
  stream.getTracks().forEach(t=> pc.addTrack(t, stream));
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  wsSend({ type:'offer', room:ROOM, from:MY_ID, to:peerId, payload:offer });
}

async function handleOffer(from, offer){
  const pc = pcs.get(from) || createPeer(from);
  const stream = await ensureMic();
  stream.getTracks().forEach(t=> pc.addTrack(t, stream));
  await pc.setRemoteDescription(new RTCSessionDescription(offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  wsSend({ type:'answer', room:ROOM, from:MY_ID, to:from, payload:answer });
}

async function handleAnswer(from, answer){
  const pc = pcs.get(from) || createPeer(from);
  await pc.setRemoteDescription(new RTCSessionDescription(answer));
}

function handleIce(from, cand){
  const pc = pcs.get(from) || createPeer(from);
  try{ pc.addIceCandidate(new RTCIceCandidate(cand)); }catch(e){ log('ICE add error', e); }
}

// UI
$('btnMute').addEventListener('click', ()=>{
  if (!localStream) return;
  localStream.getAudioTracks().forEach(t=> t.enabled = !t.enabled);
  setStatus(localStream.getAudioTracks().every(t=>t.enabled)? '‡πÑ‡∏°‡∏Ñ‡πå‡πÄ‡∏õ‡∏¥‡∏î' : '‡πÑ‡∏°‡∏Ñ‡πå‡∏õ‡∏¥‡∏î');
});

// Start
(async function main(){
  await ensureMic();
  setStatus('‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‚Ä¶');
  ws = new WebSocket(SIGNAL_URL);
  ws.onopen = ()=>{ setStatus('‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡πâ‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß'); wsSend({ type:'join', room:ROOM, from:MY_ID }); };
  ws.onclose = ()=> setStatus('‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏ï‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠');
  ws.onmessage = async (ev)=>{
    const msg = JSON.parse(ev.data||'{}');
    if (msg.room !== ROOM) return;
    if (msg.from === MY_ID) return;
    switch(msg.type){
      case 'peers': (msg.payload||[]).forEach(pid=> callPeer(pid)); break; // auto-call everyone present
      case 'join': callPeer(msg.from); break; // call newcomers
      case 'offer': if (msg.to === MY_ID) handleOffer(msg.from, msg.payload); break;
      case 'answer': if (msg.to === MY_ID) handleAnswer(msg.from, msg.payload); break;
      case 'ice': if (msg.to === MY_ID) handleIce(msg.from, msg.payload); break;
      case 'leave': removePeerEl(msg.from); const pc = pcs.get(msg.from); if (pc){ try{ pc.close(); }catch{} pcs.delete(msg.from); } break;
    }
  };
  window.addEventListener('beforeunload', ()=>{ try{ wsSend({ type:'leave', room:ROOM, from:MY_ID }); }catch{} });
})();
</script>
</body>
</html>`;

app.get('/', (req, res) => {
  res.set('Content-Type', 'text/html; charset=utf-8');
  res.send(CLIENT_HTML);
});

const server = http.createServer(app);

// ---- Tiny single-room signaling over WebSocket ----
const wss = new WebSocketServer({ server, path: '/ws' });
const clients = new Set(); // single room: everyone here

wss.on('connection', (ws) => {
  ws.id = Math.random().toString(36).slice(2,10);
  clients.add(ws);

  ws.on('message', (buf) => {
    let msg = {}; try { msg = JSON.parse(buf.toString()); } catch {}
    const { type, room, from, to, payload } = msg;

    if (type === 'join') {
      // send current peers to the new joiner (excluding self)
      const peers = Array.from(clients).filter(c => c !== ws).map(c => c.id);
      ws.send(JSON.stringify({ type:'peers', room:'lobby', from:'server', payload: peers }));
      // notify others about this joiner
      broadcast({ type:'join', room:'lobby', from: from || ws.id }, ws);
      ws.id = from || ws.id; // align to client-provided id
      return;
    }

    if (['offer','answer','ice','leave'].includes(type)) {
      // relay targeted messages
      clients.forEach(c => {
        if (!to || c.id === to) {
          try { c.send(JSON.stringify({ type, room:'lobby', from: from || ws.id, to, payload })); } catch {}
        }
      });
    }
  });

  ws.on('close', () => {
    clients.delete(ws);
    broadcast({ type:'leave', room:'lobby', from: ws.id });
  });
});

function broadcast(obj, exclude){
  const data = JSON.stringify(obj);
  clients.forEach(c => { if (c !== exclude) { try { c.send(data); } catch {} } });
}

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => console.log('Single-room voice chat on http://localhost:'+PORT));
