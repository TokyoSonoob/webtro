<!--
Auto‚ÄëMesh Voice Chat
- Client: Single HTML page (audio‚Äëonly) that auto‚Äëconnects everyone in the same room.
- Signaling: Minimal WebSocket broadcast server (provided below for Node.js or Cloudflare Workers).

How it works
1) Open the client page on multiple devices/browsers with the SAME ?room=xxxx (defaults to "lobby").
2) Each client joins the room over WebSocket, auto‚Äëcalls everyone else (full mesh), and auto‚Äëanswers incoming.
3) Audio‚Äëonly. No Firebase. TURN optional (recommended for tougher NATs).

Limits
- Full mesh works best for ~2‚Äì4 people. For larger groups, use an SFU.
-->
<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Auto‚ÄëMesh Voice Chat (WebRTC + WS signaling)</title>
  <style>
    :root{--bg:#0b1220;--card:#111827;--muted:#9CA3AF;--b:#1f2937;--pri:#8b5cf6}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:#fff;font:16px/1.4 system-ui,Segoe UI,Roboto,Arial}
    .wrap{max-width:920px;margin:0 auto;padding:16px}
    h1{margin:0 0 6px;color:var(--pri)}
    .muted{color:var(--muted)}
    .card{background:var(--card);border:1px solid var(--b);border-radius:14px;padding:14px;margin-top:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    code{background:#0b1220;border:1px solid var(--b);padding:2px 6px;border-radius:6px}
    button{cursor:pointer;border:0;border-radius:10px;padding:8px 12px;font-weight:700}
    .btn{background:var(--pri);color:#fff}
    audio{width:100%}
    .pill{font-size:12px;border:1px solid #2a385c;background:#0e1730;padding:2px 8px;border-radius:999px}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üìû Auto‚ÄëMesh Voice Chat</h1>
    <p class="muted">‡πÄ‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡∏à‡∏∞‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ñ‡∏∂‡∏á‡∏Å‡∏±‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ Firebase). ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ <b>WebSocket signaling</b> ‡πÄ‡∏•‡πá‡∏Å‡πÜ ‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏à‡∏∏‡∏î (‡∏°‡∏µ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÉ‡∏´‡πâ‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á).</p>

    <div class="card">
      <div class="row">
        <div>Room:</div>
        <code id="room"></code>
        <div class="pill" id="myid"></div>
        <button id="btnMute" class="">üîá ‡∏õ‡∏¥‡∏î/‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡∏Ñ‡πå</button>
      </div>
      <div id="status" class="muted" style="margin-top:8px">‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‚Ä¶</div>
    </div>

    <div class="card">
      <h3>‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏£‡πà‡∏ß‡∏°‡∏´‡πâ‡∏≠‡∏á</h3>
      <div id="peers" class="grid"></div>
      <p class="muted" style="margin-top:8px">‡πÄ‡∏Ç‡πâ‡∏° NAT ‡∏°‡∏≤‡∏Å‡πÜ ‡∏≠‡∏≤‡∏à‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ TURN. ‡πÄ‡∏ï‡∏¥‡∏°‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ <code>ICE_SERVERS</code> ‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á</p>
    </div>
  </div>

<script>
// ====== Config ======
const SIGNAL_URL = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws';
// If your signaling runs elsewhere, set e.g. 'wss://your-domain.example/ws'

const ICE_SERVERS = [
  { urls: 'stun:stun.l.google.com:19302' },
  // Optional TURN example:
  // { urls:'turn:YOUR_TURN_HOST:3478', username:'user', credential:'pass' }
];

// ====== Helpers ======
const params = new URLSearchParams(location.search);
const ROOM = params.get('room') || 'lobby';
const MY_ID = Math.random().toString(36).slice(2,10);
const log = (...a)=>{ console.log('[client]', ...a); };
const $ = (id)=>document.getElementById(id);
$('room').textContent = ROOM;
$('myid').textContent = 'ID: '+MY_ID;

function setStatus(t){ $('status').textContent = t; }

// ====== Signaling (WebSocket) protocol ======
// Messages: {type, room, from, to?, payload}
// types: 'join', 'peers', 'offer', 'answer', 'ice', 'leave'
let ws;
function wsSend(msg){ if (ws && ws.readyState === 1) ws.send(JSON.stringify(msg)); }

// ====== WebRTC state ======
let localStream;
const pcs = new Map(); // peerId -> RTCPeerConnection
const senders = new Map(); // peerId -> RTCRtpSender[]

function createPeer(peerId){
  const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
  pcs.set(peerId, pc);

  pc.onicecandidate = (ev)=>{
    if (ev.candidate) wsSend({ type:'ice', room:ROOM, from:MY_ID, to:peerId, payload:ev.candidate });
  };
  pc.oniceconnectionstatechange = ()=>{
    log(peerId, 'ice:', pc.iceConnectionState);
    if (['failed','disconnected','closed'].includes(pc.iceConnectionState)) removePeerEl(peerId);
  };
  pc.ontrack = (ev)=>{
    attachRemoteAudio(peerId, ev.streams[0]);
  };
  return pc;
}

function attachRemoteAudio(peerId, stream){
  let el = document.getElementById('aud_'+peerId);
  if (!el){
    const wrap = document.createElement('div');
    wrap.id = 'wrap_'+peerId; wrap.className = 'card';
    const title = document.createElement('div');
    title.textContent = 'Peer '+peerId;
    const audio = document.createElement('audio');
    audio.id = 'aud_'+peerId; audio.autoplay = true; audio.playsInline = true; audio.controls = true;
    wrap.appendChild(title); wrap.appendChild(audio);
    $('peers').appendChild(wrap);
    el = audio;
  }
  el.srcObject = stream;
}

function removePeerEl(peerId){
  const wrap = document.getElementById('wrap_'+peerId);
  if (wrap && wrap.parentNode) wrap.parentNode.removeChild(wrap);
}

async function ensureMic(){
  if (localStream) return localStream;
  localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
  return localStream;
}

async function callPeer(peerId){
  const pc = pcs.get(peerId) || createPeer(peerId);
  const stream = await ensureMic();
  const sArr = [];
  stream.getTracks().forEach(t=> sArr.push(pc.addTrack(t, stream)));
  senders.set(peerId, sArr);

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  wsSend({ type:'offer', room:ROOM, from:MY_ID, to:peerId, payload:offer });
}

async function handleOffer(from, offer){
  const pc = pcs.get(from) || createPeer(from);
  const stream = await ensureMic();
  const sArr = [];
  stream.getTracks().forEach(t=> sArr.push(pc.addTrack(t, stream)));
  senders.set(from, sArr);

  await pc.setRemoteDescription(new RTCSessionDescription(offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  wsSend({ type:'answer', room:ROOM, from:MY_ID, to:from, payload:answer });
}

async function handleAnswer(from, answer){
  const pc = pcs.get(from) || createPeer(from);
  await pc.setRemoteDescription(new RTCSessionDescription(answer));
}

function handleIce(from, cand){
  const pc = pcs.get(from) || createPeer(from);
  try { pc.addIceCandidate(new RTCIceCandidate(cand)); } catch (e){ log('ICE add error', e); }
}

function cleanup(){
  pcs.forEach((pc, id)=>{ try{ pc.getSenders().forEach(s=> s.track && s.track.stop()); }catch{} try{ pc.close(); }catch{} });
  pcs.clear(); senders.clear();
}

// UI controls
$('btnMute').addEventListener('click', ()=>{
  if (!localStream) return;
  localStream.getAudioTracks().forEach(t=> t.enabled = !t.enabled);
  setStatus(localStream.getAudioTracks().every(t=>t.enabled)? '‡πÑ‡∏°‡∏Ñ‡πå‡πÄ‡∏õ‡∏¥‡∏î' : '‡πÑ‡∏°‡∏Ñ‡πå‡∏õ‡∏¥‡∏î');
});

// Start
(async function main(){
  setStatus('‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‚Ä¶');
  try { await ensureMic(); } catch(e){ setStatus('‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÑ‡∏°‡∏Ñ‡πå‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô'); return; }

  ws = new WebSocket(SIGNAL_URL);
  ws.onopen = ()=>{
    setStatus('‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡πâ‡∏≠‡∏á '+ROOM+' ‡πÅ‡∏•‡πâ‡∏ß');
    wsSend({ type:'join', room:ROOM, from:MY_ID });
  };
  ws.onmessage = async (ev)=>{
    const msg = JSON.parse(ev.data||'{}');
    if (msg.room !== ROOM) return;
    if (msg.from === MY_ID) return; // ignore own

    switch(msg.type){
      case 'peers':{
        // server sends current peer list (excluding me). Auto-call all.
        (msg.payload||[]).forEach(pid=>{ if (pid !== MY_ID) callPeer(pid); });
        break;
      }
      case 'join':{
        // someone new joined ‚Üí I call them (to avoid double offer, simple rule: everyone calls newcomers)
        callPeer(msg.from);
        break;
      }
      case 'offer':{
        if (msg.to === MY_ID) handleOffer(msg.from, msg.payload);
        break;
      }
      case 'answer':{
        if (msg.to === MY_ID) handleAnswer(msg.from, msg.payload);
        break;
      }
      case 'ice':{
        if (msg.to === MY_ID) handleIce(msg.from, msg.payload);
        break;
      }
      case 'leave':{
        removePeerEl(msg.from);
        const pc = pcs.get(msg.from); if (pc){ try{ pc.close(); }catch{} pcs.delete(msg.from); }
        break;
      }
    }
  };
  ws.onclose = ()=>{ setStatus('‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏ï‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠'); cleanup(); };
  window.addEventListener('beforeunload', ()=>{ try{ wsSend({type:'leave', room:ROOM, from:MY_ID}); }catch{} });
})();
</script>
</body>
</html>

<!-- ================== Tiny Signaling Server (Option A: Node.js) ==================
Save as server.js, install deps, run:
  npm i ws express
  node server.js
Then host the above HTML and proxy /ws to this server (or serve it together).

const express = require('express');
const { WebSocketServer } = require('ws');
const app = express();
const httpServer = app.listen(process.env.PORT || 3000, ()=>console.log('HTTP on', httpServer.address().port));
const wss = new WebSocketServer({ server: httpServer, path: '/ws' });

const rooms = new Map(); // room -> Set(ws)
function listIds(room){ return Array.from(rooms.get(room)||[]).map(c=>c.id); }

wss.on('connection', (ws, req)=>{
  ws.id = Math.random().toString(36).slice(2,10);
  ws.room = null;
  ws.on('message', (buf)=>{
    let msg = {}; try{ msg = JSON.parse(buf.toString()); }catch{}
    const { type, room, from, to, payload } = msg;
    if (type === 'join'){
      ws.id = from || ws.id; ws.room = room;
      if (!rooms.has(room)) rooms.set(room, new Set());
      rooms.get(room).add(ws);
      // send current peers
      const peers = listIds(room).filter(id=> id !== ws.id);
      ws.send(JSON.stringify({ type:'peers', room, from:'server', payload:peers }));
      // notify others that this peer joined
      rooms.get(room).forEach(c=>{ if (c !== ws) c.send(JSON.stringify({ type:'join', room, from: ws.id })); });
      return;
    }
    if (!ws.room) return;
    // relay targeted messages within room
    if (['offer','answer','ice','leave'].includes(type)){
      rooms.get(ws.room)?.forEach(c=>{
        if (!to || c.id === to){ c.send(JSON.stringify({ type, room: ws.room, from, to, payload })); }
      });
    }
  });
  ws.on('close', ()=>{
    const set = rooms.get(ws.room); if (set){ set.delete(ws); set.forEach(c=> c.send(JSON.stringify({ type:'leave', room: ws.room, from: ws.id }))); if (!set.size) rooms.delete(ws.room); }
  });
});

// ============================================================================= -->

<!-- ================== Tiny Signaling Server (Option B: Cloudflare Workers) ==================
// Deploy as a Worker; bind a Durable Object named "Hub" as HUB. Then map route /ws to this Worker.
export default {
  fetch(request, env) {
    const url = new URL(request.url);
    if (url.pathname === '/ws') return env.HUB.fetch(request);
    return new Response('OK', { status: 200 });
  }
}

export class Hub {
  constructor(state, env){ this.state = state; this.env = env; this.conns = new Map(); }
  async fetch(request){
    if (request.headers.get('Upgrade') !== 'websocket') return new Response('Expected WebSocket', { status: 400 });
    const [client, server] = Object.values(new WebSocketPair());
    const id = Math.random().toString(36).slice(2,10);
    this.state.acceptWebSocket(server, [id]);
    return new Response(null, { status: 101, webSocket: client });
  }
  webSocketMessage(ws, msg){
    let data={}; try{ data = JSON.parse(msg); }catch{}
    const { type, room, from, to } = data;
    if (type === 'join'){
      ws.id = from; ws.room = room;
      if (!this.rooms) this.rooms = new Map();
      if (!this.rooms.has(room)) this.rooms.set(room, new Set());
      this.rooms.get(room).add(ws);
      const peers = Array.from(this.rooms.get(room)).map(c=>c.id).filter(id=>id!==ws.id);
      ws.send(JSON.stringify({ type:'peers', room, from:'server', payload:peers }));
      this.rooms.get(room).forEach(c=>{ if (c!==ws) c.send(JSON.stringify({ type:'join', room, from: ws.id })); });
      return;
    }
    if (!ws.room) return;
    if (['offer','answer','ice','leave'].includes(type)){
      this.rooms.get(ws.room)?.forEach(c=>{ if (!to || c.id === to) c.send(JSON.stringify({ ...data })); });
    }
  }
  webSocketClose(ws){
    if (!this.rooms) return;
    const set = this.rooms.get(ws.room); if (set){ set.delete(ws); set.forEach(c=> c.send(JSON.stringify({ type:'leave', room: ws.room, from: ws.id }))); if (!set.size) this.rooms.delete(ws.room); }
  }
}
// ============================================================================= -->
